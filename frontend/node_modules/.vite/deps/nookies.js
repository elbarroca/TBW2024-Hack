import {
  require_set_cookie
} from "./chunk-R2W4NKWS.js";
import {
  __commonJS
} from "./chunk-4B2QHNJT.js";

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(";");
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var index = pair.indexOf("=");
        if (index < 0) {
          continue;
        }
        var key = pair.substring(0, index).trim();
        if (void 0 == obj[key]) {
          var val = pair.substring(index + 1, pair.length).trim();
          if (val[0] === '"') {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/nookies/dist/utils.js
var require_utils = __commonJS({
  "node_modules/nookies/dist/utils.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.areCookiesEqual = exports.hasSameProperties = exports.createCookie = exports.isBrowser = void 0;
    function isBrowser() {
      return typeof window !== "undefined";
    }
    exports.isBrowser = isBrowser;
    function createCookie(name, value, options) {
      var sameSite = options.sameSite;
      if (sameSite === true) {
        sameSite = "strict";
      }
      if (sameSite === void 0 || sameSite === false) {
        sameSite = "lax";
      }
      var cookieToSet = __assign(__assign({}, options), { sameSite });
      delete cookieToSet.encode;
      return __assign({ name, value }, cookieToSet);
    }
    exports.createCookie = createCookie;
    function hasSameProperties(a, b) {
      var aProps = Object.getOwnPropertyNames(a);
      var bProps = Object.getOwnPropertyNames(b);
      if (aProps.length !== bProps.length) {
        return false;
      }
      for (var i = 0; i < aProps.length; i++) {
        var propName = aProps[i];
        if (a[propName] !== b[propName]) {
          return false;
        }
      }
      return true;
    }
    exports.hasSameProperties = hasSameProperties;
    function areCookiesEqual(a, b) {
      var sameSiteSame = a.sameSite === b.sameSite;
      if (typeof a.sameSite === "string" && typeof b.sameSite === "string") {
        sameSiteSame = a.sameSite.toLowerCase() === b.sameSite.toLowerCase();
      }
      return hasSameProperties(__assign(__assign({}, a), { sameSite: void 0 }), __assign(__assign({}, b), { sameSite: void 0 })) && sameSiteSame;
    }
    exports.areCookiesEqual = areCookiesEqual;
  }
});

// node_modules/nookies/dist/index.js
var require_dist = __commonJS({
  "node_modules/nookies/dist/index.js"(exports) {
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.destroyCookie = exports.setCookie = exports.parseCookies = void 0;
    var cookie = require_cookie();
    var setCookieParser = require_set_cookie();
    var utils_1 = require_utils();
    function parseCookies(ctx, options) {
      var _a, _b;
      if ((_b = (_a = ctx === null || ctx === void 0 ? void 0 : ctx.req) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.cookie) {
        return cookie.parse(ctx.req.headers.cookie, options);
      }
      if (utils_1.isBrowser()) {
        return cookie.parse(document.cookie, options);
      }
      return {};
    }
    exports.parseCookies = parseCookies;
    function setCookie(ctx, name, value, options) {
      var _a, _b;
      if (options === void 0) {
        options = {};
      }
      if (((_a = ctx === null || ctx === void 0 ? void 0 : ctx.res) === null || _a === void 0 ? void 0 : _a.getHeader) && ctx.res.setHeader) {
        if ((_b = ctx === null || ctx === void 0 ? void 0 : ctx.res) === null || _b === void 0 ? void 0 : _b.finished) {
          console.warn('Not setting "' + name + '" cookie. Response has finished.');
          console.warn("You should set cookie before res.send()");
          return {};
        }
        var cookies = ctx.res.getHeader("Set-Cookie") || [];
        if (typeof cookies === "string")
          cookies = [cookies];
        if (typeof cookies === "number")
          cookies = [];
        var parsedCookies = setCookieParser.parse(cookies, {
          decodeValues: false
        });
        var newCookie_1 = utils_1.createCookie(name, value, options);
        var cookiesToSet_1 = [];
        parsedCookies.forEach(function(parsedCookie) {
          if (!utils_1.areCookiesEqual(parsedCookie, newCookie_1)) {
            var serializedCookie = cookie.serialize(parsedCookie.name, parsedCookie.value, __assign({
              // we prevent reencoding by default, but you might override it
              encode: function(val) {
                return val;
              }
            }, parsedCookie));
            cookiesToSet_1.push(serializedCookie);
          }
        });
        cookiesToSet_1.push(cookie.serialize(name, value, options));
        ctx.res.setHeader("Set-Cookie", cookiesToSet_1);
      }
      if (utils_1.isBrowser()) {
        if (options && options.httpOnly) {
          throw new Error("Can not set a httpOnly cookie in the browser.");
        }
        document.cookie = cookie.serialize(name, value, options);
      }
      return {};
    }
    exports.setCookie = setCookie;
    function destroyCookie(ctx, name, options) {
      return setCookie(ctx, name, "", __assign(__assign({}, options || {}), { maxAge: -1 }));
    }
    exports.destroyCookie = destroyCookie;
    exports.default = {
      set: setCookie,
      get: parseCookies,
      destroy: destroyCookie
    };
  }
});
export default require_dist();
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=nookies.js.map
